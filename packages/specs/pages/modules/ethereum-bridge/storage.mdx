import { Callout } from 'nextra-theme-docs'

## Storage

To make including new events easy, Namada takes the approach of always overwriting 
the state with the new state rather than applying state diffs. The storage 
keys involved are:
```
# all values are Borsh-serialized
/eth_msgs/\$msg_hash/body : EthereumEvent
/eth_msgs/\$msg_hash/seen_by : Vec<Address>
/eth_msgs/\$msg_hash/voting_power: (u64, u64)  # reduced fraction < 1 e.g. (2, 3)
/eth_msgs/\$msg_hash/seen: bool
```

`\$msg_hash` is the SHA256 digest of the Borsh serialization of the relevant 
`EthereumEvent`.

Changes to this `/eth_msgs` storage subspace are only ever made by internal 
transactions crafted and applied by all nodes based on the aggregate of vote 
extensions for the last Cometbft round. That is, changes to `/eth_msgs` happen 
in block `n+1` in a deterministic manner based on the vote extensions of the 
Cometbft round for block `n`.

The `/eth_msgs` storage subspace does not belong to any account and cannot be 
modified by transactions submitted from outside of the ledger via Cometbft. 
The storage will be guarded by a special validity predicate - `EthSentinel` - 
that is part of the verifier set by default for every transaction, but will be 
removed by the ledger code for the specific permitted transactions that are 
allowed to update `/eth_msgs`.

### Including events into storage

For every Namada block proposal, the vote extension of a validator should include
the events of the Ethereum blocks they have seen via their full node such that:
1. The storage value `/eth_msgs/\$msg_hash/seen_by` does not include their
   address.
2. It's correctly formatted.
3. It's reached the required number of confirmations on the Ethereum chain

Each event that a validator is voting to include must be individually signed by 
them. If the validator is not voting to include any events, they must still
provide a signed voted extension indicating this.

The vote extension data field will be a Borsh-serialization of something like the following.
```rust
pub struct VoteExtension(Vec<SignedEthEvent>);

/// A struct used by validators to sign that they have seen a particular
/// ethereum event. These are included in vote extensions
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, BorshSchema)]
pub struct SignedEthEvent {
    /// The address of the signing validator
    signer: Address,
    /// The proportion of the total voting power held by the validator
    power: FractionalVotingPower,
    /// The event being signed and the block height at which
    /// it was seen. We include the height as part of enforcing
    /// that a block proposer submits vote extensions from
    /// **the previous round only**
    event: Signed<(EthereumEvent, BlockHeight)>,
}
```

These vote extensions will be given to the next block proposer who will
aggregate those that it can verify and will inject a protocol transaction
(the "vote extensions" transaction).

```rust
pub struct MultiSigned<T: BorshSerialize + BorshDeserialize> {
    /// Arbitrary data to be signed
    pub data: T,
    /// The signature of the data
    pub sigs: Vec<common::Signature>,
}

pub struct MultiSignedEthEvent {
    /// Address and voting power of the signing validators
    pub signers: Vec<(Address, FractionalVotingPower)>,
    /// Events as signed by validators
    pub event: MultiSigned<(EthereumEvent, BlockHeight)>,
}

pub enum ProtocolTxType {
    EthereumEvents(Vec<MultiSignedEthEvent>)
}
```

This vote extensions transaction will be signed by the block proposer. 
Validators will check this transaction and the validity of the new votes as 
part of `ProcessProposal`, this includes checking:
- signatures
- that votes are really from active validators
- the calculation of backed voting power

It is also checked that each vote extension came from the previous round, 
requiring validators to sign over the Namada block height with their vote
extension. Furthermore, the vote extensions included by the block proposer
should have at least 2 / 3 of the total voting power of the previous round 
backing it. Otherwise the block proposer would not have passed the 
`FinalizeBlock` phase of the last round. These checks are to prevent censorship 
of events from validators by the block proposer.

In `FinalizeBlock`, we derive a second transaction (the "state update" 
transaction) from the vote extensions transaction that:
- calculates the required changes to `/eth_msgs` storage and applies it
- acts on any `/eth_msgs/\$msg_hash` where `seen` is going from `false` to `true`
  (e.g. appropriately minting wrapped Ethereum assets)

This state update transaction will not be recorded on chain but will be 
deterministically derived from the vote extensions transaction, which is 
recorded on chain. All ledger nodes will derive and apply this transaction to 
their own local blockchain state, whenever they receive a block with a vote 
extensions transaction. This transaction cannot require a protocol signature 
as even non-validator full nodes of Namada will be expected to do this.

The value of `/eth_msgs/\$msg_hash/seen` will also indicate if the event 
has been acted on on the Namada side. The appropriate transfers of tokens to the
given user will be included on chain free of charge and requires no
additional actions from the end user.

## Ethereum Events Attestation

Namada stores events from the smart contracts of its bridge. Namada includes events that have been voted by at least one
validator, but will not act on them until they have been `seen` by a
weighted average of more than $\frac{2}{3}$ of the voting power
available across all epochs of the tally. Generically, Namada considers some
tally $t$ `seen` if it satisfies the following inequality:

$$\sum_{E \in \xi} (\frac{\sigma(E)}{\sum_{E' \in \xi} \sigma(E')} \cdot F_E) > \frac{2}{3}$$

Where $\xi$ is the set of epochs when $t$ took place, $\sigma$ is a
function mapping an epoch to its total voting power and $F_E$ is the
total fractional voting power aggregated behind a tally at some epoch
$E$ (for instance, at $E_0$,
$F_{E_0} = \frac{\frac{1}{2} \cdot \sigma(E_0)}{\sigma(E_0)}$). The only
way to break the security of $t$ is if a set of Byzantine validators
control an average of $\frac{1}{3}$ of the voting power available across
$\xi$.

There will be multiple types of events emitted. Validators should ignore
improperly formatted events. ABI encoded events from Ethereum are
decoded by [`ethbridge-rs`](https://github.com/heliaxdev/ethbridge-rs),
and converted to a Rust enum type (`EthereumEvent`) by Namada validators
before being included in vote extensions or stored on chain.

``` rust
pub enum EthereumEvent {
    // Namada has different variants corresponding to different types
    // of raw events Namada receives from Ethereum
    TransfersToNamada(Vec<TransferToNamada>)
    // ...
}
```

Validators may never vote more than once on a given event. To ensure
that this invariant is held, Namada keep track of who voted on some event
and events are timed out if they are not `seen` within the span of
`unbonding_length` epochs, which corresponds to the period of time
necessary for bonded tokens to be returned to an address (check the
[relevant proof-of-stake
section](../proof-of-stake/reward-distribution.mdx) for more
details). Timing out an event consists of removing all its associated
state from storage. Therefore, this mechanism serves another purpose:
purging forged events from storage, voted on by Byzantine validators.

## Minimum confirmations

There will be a protocol-specified minimum number of confirmations that
events must reach on the Ethereum chain, before validators can vote to
include them on Namada. This minimum number of confirmations will be
changeable via governance.

`TransferToNamada` events may include a custom minimum number of
confirmations that must be at least the protocol-specified minimum
number of confirmations. However, this value is initially set to
**100**.

Validators must not vote to include events that have _yet_ to meet the
required number of confirmations. Votes on unconfirmed events will
eventually time out in storage.
Assuming that an honest
majority of validators is operating Namada (i.e. $\ge \frac{2}{3}$ by
voting power across all epochs in the tally), only confirmed events will
eventually become `seen`.

## Vote extension protocol transactions

A batch of Ethereum events $E$ newly confirmed at some block height $H$
is included by some validator $v$ in a protocol transaction Namada dubs the
*Ethereum events vote extension*. The vote extension is signed by the
protocol key of $v$, uniquely identifying $v$'s vote on some Ethereum
event $e \in E$ at $H$.

Namada validators perform votes on other kinds of data, namely:

1)  Validator set update vote extensions. As the name implies, these are
    used to sign off on the set of validators of some epoch $i' = i + 1$
    by the validators of epoch $i$. The proof (quorum of signatures) is
    used to update the validator set reflected in the Ethereum smart
    contracts of the bridge.
2)  Bridge pool root vote extensions. These vote extensions are used to
    reach a quorum decision on the most recent root and nonce of the
    [Ethereum bridge pool](./transfers_to_ethereum.mdx).

These protocol transactions are only ever included on-chain if the
Tendermint version that is being used to run the ledger does not include
a full ABCI++ (i.e. ABCI 2.0) implementation. Alternatively, nodes
receive vote extensions from the previously decided block, never lagging
behind more than one block height. Without ABCI++, vote extensions are
included in arbitrary blocks, based on the contention of block
proposers' mempools. This effectively means that a vote extension for
some height $H_0$ may only be acted upon at some height $H \gg H_0$, or
even evicted from the mempool altogether, if it is never proposed.

## Storage

To make including new events easy, Namada takes the approach of always
overwriting the state with the new state rather than applying state
diffs. The storage keys involved are:

```
# all values are Borsh-serialized
/eth_msgs/$msg_hash/body: EthereumEvent # the event to be voted on
/eth_msgs/$msg_hash/seen_by: BTreeMap<Address, BlockHeight> # mapping from a validator to the Namada height at which the event was observed to be confirmed by said validator
/eth_msgs/$msg_hash/voting_power: BTreeMap<Epoch, FractionalVotingPower> # mapping from epochs to aggregated voting powers, in the form of a reduced fraction < 1 e.g. (2, 3)
/eth_msgs/$msg_hash/seen: bool # >= 2/3 average voting power across all epochs it was voted on
/eth_msgs/$msg_hash/voting_started_epoch: Epoch # epoch when the tally started
```

Where `$msg_hash` is the SHA256 digest of the Borsh serialization of
some `EthereumEvent`.

Changes to this `/eth_msgs` storage subspace are only ever made by nodes
as part of the ledger code based on the aggregate of votes by validators
for specific events. That is, changes to `/eth_msgs` happen in block `n`
in a deterministic manner based on the votes included in the block
proposal for block `n`. Depending on the underlying Tendermint version,
these votes will either be included as vote extensions or as protocol
transactions.

The `/eth_msgs` storage subspace will belong to the `EthBridge` validity
predicate. It should disallow any changes to this storage from wasm
transactions.

### Including events into storage

For every Namada block proposal, the proposer should include the votes
for events from other validators into their proposal. If the underlying
Tendermint version supports vote extensions, consensus invariants
guarantee that a quorum of votes from the previous block height can be
included. Otherwise, validators can only submit votes by broadcasting
protocol transactions, which comes with less guarantees (i.e. no
consensus finality).

The vote of a validator should include each event of the Ethereum blocks
their full node has seen that satisfies the following conditions:

1.  The event is correctly formatted.
2.  It has reached the required number of confirmations on the Ethereum
    chain.
3.  If a transfer to Ethereum event is detected, the underlying asset
    must be whitelisted on the Ethereum bridge smart contracts.

Each event that a validator is voting to include must be individually
signed by them. If the validator is not voting to include any events,
they must still provide a signed empty vector of events to indicate
this.

The votes will include be a Borsh-serialization of something like the
following:

``` rust
/// This struct will be created and signed over by each
/// consensus validator, to be included as a vote extension at the end of a
/// Tendermint PreCommit phase or as Protocol Tx.
pub struct Vext {
    /// The block height for which this [`Vext`] was made.
    pub block_height: BlockHeight,
    /// The address of the signing validator
    pub validator_addr: Address,
    /// The new ethereum events seen. These should be
    /// deterministically ordered.
    pub ethereum_events: Vec<EthereumEvent>,
}
```

These votes will be delivered to subsequent block proposers who will
aggregate those that they can verify and will inject them into their
proposal. With ABCI++ this involves creating a new protocol transaction,
dubbed a _digest_, comprised of multiple individual votes on Ethereum
events.

Validators will check the validity of Ethereum events vote extensions as
part of `ProcessProposal`. This includes checking, among other things:

-   The height within the vote extension is correct (e.g. not ahead of
    the last block height). If vote extensions are supported, it is also
    checked that each vote extension came from the previous height.
    Signing over the block height also acts as a replay protection
    mechanism.
-   That signatures come from consensus validators, at the epoch the
    vote extensions originated from.
-   The bridge was active when the extension was signed.
-   Ethereum event nonces, to reject attempts to replay transactions
    through the bridge.

Furthermore, with ABCI++ enabled, the vote extensions included by the
block proposer should have a quorum of the total voting power of the
epoch of the block height behind it. Otherwise the block proposer would
not have passed the `FinalizeBlock` phase of the last round of the last
block.

These checks are to prevent censorship of events from validators by the
block proposer. If ABCI++ is not enabled, unfortunately these checks
cannot be made.

In `FinalizeBlock`, Namada derives a second transaction (the "state update"
transaction) from the vote aggregation that:

-   Calculates the required changes to `/eth_msgs` storage and applies
    them.
-   Acts on any `/eth_msgs/$msg_hash` where `seen` is going from `false`
    to `true` (e.g. appropriately minting wrapped Ethereum assets).

This state update transaction will not be recorded on chain but will be
deterministically derived from the protocol transaction including the
aggregation of votes, which is recorded on chain. All ledger nodes will
derive and apply the appropriate state changes to their own local
blockchain storage.

The value of `/eth_msgs/$msg_hash/seen` will also indicate if the event
has been acted upon on the Namada side. The appropriate transfers of
tokens to the given user will be included on chain free of charge and
requires no additional actions from the end user.


# Ethereum Smart Contracts

## Contracts

There are five smart contracts that make up an Ethereum bridge deployment.

- Proxy
- Bridge
- Governance
- Vault
- wNAM

### Proxy

The _Proxy_ contract serves as a dumb storage for holding the addresses of other
contracts, specifically the _Governance_ contract, the _Vault_ contract and the
current _Bridge_ contract. Once deployed, it is modifiable only by the
_Governance_ contract, to update the address for which contract is the current
_Bridge_ contract.

The _Proxy_ contract is fixed forever once the bridge has been deployed.

### Bridge

The _Bridge_ contract is the only contract that unprivileged users of the bridge
may interact with. It provides methods for transferring ERC20s to Namada
(holding them in escrow in the _Vault_), as well as releasing escrowed ERC20s
from the _Vault_ for transfers made from Namada to Ethereum. It holds a
whitelist of ERC20s that may cross the bridge, and this whitelist may be updated
by the _Governance_ contract.

### Governance

The _Governance_ contract may "upgrade" the bridge by updating the _Proxy_
contract to point to a new _Bridge_ contract and/or a new _Governance_ contract.
It may also withdraw all funds from the _Vault_ to any specified Ethereum
address, if a quorum of validators choose to do so.

### wNAM

The _wNAM_ contract is a simple ERC20 token with a fixed supply, which is all
minted when the bridge is first deployed. After initial deployment, the entire
supply of _wNAM_ belongs to the _Vault_ contract. As NAM is transferred from
Namada to Ethereum, wNAM may be released from the _Vault_ by the _Bridge_.

The _wNAM_ contract is fixed forever once the bridge has been deployed.

### Vault

The _Vault_ contract holds in escrow any ERC20 tokens that have been sent over
the bridge to Namada, as well as a supply of _wNAM_ ERC20s to represent NAM that
has been sent from Namada to Ethereum. Funds held by the _Vault_ may only be
spendable by the current _Bridge_ contract. When ERC20 tokens are transferred
from Ethereum to Namada, they must be deposited to the _Vault_ via the _Bridge_
contract.

The _Vault_ contract is fixed forever once the bridge has been deployed.

## Namada-side configuration

When an account on Namada becomes a validator, they must provide two Ethereum
secp256k1 keys:

- The bridge key - a hot key for normal operations.
- The governance key - a cold key for exceptional operations, like emergency
  withdrawal from the bridge.

These keys are used to control the bridge smart contracts, via signing of
messages. Validators should be challenged periodically to prove they still retain
knowledge of their governance key, which is not regularly used.

## Deployment

The contracts should be deployable by anyone to any EVM chain using an automated
script. The following configuration should be agreed up front by Namada
governance before deployment:

- Details of the initial consensus validator set that will control the bridge -
  specifically, for each validator:
  - Their hot Ethereum address.
  - Their cold Ethereum address.
  - Their voting power on Namada for the epoch when the bridge will launch.
- The total supply of the wNAM ERC20 token, which will represent Namada-native
  NAM on the EVM chain.
- An initial whitelist of ERC20 tokens that may cross the bridge from Ethereum
  to Namada - specifically, for each whitelisted ERC20:
    - The Ethereum address of the ERC20 contract.
    - A cap on the total amount that may cross the bridge, in units of ERC20.

After a deployment has finished successfully, the deployer must not have any
privileged control of any of the contracts deployed. Any privileged actions must
only be possible via a message signed by a validator set that the smart
contracts are storing details of.

## Communication

### From Ethereum to Namada

A Namada chain's validators are configured to listen to events emitted by the
smart contracts pointed to by the _Proxy_ contract. The addresses of the
_Bridge_ and _Governance_ contracts are set as governance parameters in Namada storage.
Namada validators treat emitted events as authoritative and take action on them.
Namada also knows the address of the _wNAM_ ERC20 contract via a governance parameter,
and treats transfers of this ERC20 to Namada as an indication to release native NAM from
the `#EthBridge` account on Namada, rather than to mint a wrapped ERC20 as
is the case with all other ERC20s.

### From Namada to Ethereum

At any time, the _Governance_ and _Bridge_ contracts must store:

- A hash of the current Namada epoch's consensus validator set.
- A hash of another epoch's consensus validator set. When the bridge is first
  deployed, this will also be the current Namada epoch's consensus validator set,
  but after the first validator set update is submitted to the _Governance_
  smart contract, this hash will always be the next epoch's.

In the case of the _Governance_ contract, these are hashes of a map of
validator's _cold_ key addresses to their voting powers, while for the _Bridge_
contract it is hashes of a map of validator's _hot_ key addresses to their
voting powers. Namada validators may post signatures as on chain of relevant
messages to be relayed to the Ethereum bridge smart contracts (e.g. validator
set updates, pending transfers, etc.). Methods of the Ethereum bridge smart
contracts should generally accept:

- Some message.
- Full details of some consensus validator set (i.e. relevant Ethereum addresses +
  voting powers).
- Signatures over the message by validators from the consensus validator set.


Given this data, anyone should be able to make the relevant Ethereum smart
contract method call, if they are willing to pay the Ethereum gas. A call is
then authorized to happen if:

- The consensus validator set specified in the call hashes to the
  current validator set hash stored in the smart contract.
- A quorum (i.e. more than 2/3 by voting power) of the signatures over the
  message are valid.

### Validator set updates

Initial deployment aside, at the beginning of each epoch, the smart contracts
will contain details of the previous epoch's validator set and the current
epoch's validator set. Namada validators must endeavor to sign details of the
next epoch's validator set and post them on Namada chain in a protocol
transaction. Details of the next epoch's validator set and a quorum of
signatures over it by validators from the current epoch's validator set must
then be relayed to the _Governance_ contract before the end of the epoch, which
will update both the _Governance_ and _Bridge_ smart contracts to have the hash
of the next epoch's validator set. This should happen before the current Namada
epoch ends. If this does not happen, then the Namada chain will halt.

When a validator set update is submitted, the hashes for the oldest validator
set are effectively "evicted" from the _Governance_ and _Bridge_ smart
contracts. At that point, messages signed by that evicted validator set will no
longer be accepted by the bridge. In the _Bridge_ contract, the hash of the
current validator set will start to be used to authenticate messages, while
the next validator set hash will be stored internally. The _Governance_
contract will contain the hash of the next validator set hash.

#### Example flow

- Namada epoch `10` begins. Currently, the _Governance_ contract knows the
  hashes of the validator sets for epochs `9` and `10`, as does the _Bridge_
  contract.
- Validators for epoch `10` post signatures over the hash of details of the
  validator set for epoch `11` to Namada as protocol transactions.
- A point is reached during epoch `10` at which a quorum of such signatures is
  present on the Namada chain.
- A relayer submits a validator set update for epoch `11` to _Governance_, using
  a quorum of signatures from the Namada chain.
- The _Governance_ and _Bridge_ contracts now know the hashes of the validator
  sets for epochs `10` and `11`, and will accept messages signed by either of
  them. It will no longer accept messages signed by the validator set for epoch
  `9`.
- Namada progresses to epoch `11`, and the flow repeats

NB: the flow for when the bridge has just launched is similar, except the
contracts know the details of only one epoch's validator set - the launch
epoch's. E.g. if the bridge launches at epoch `10`, then initially the contracts
know the hash only for epoch `10` and not epochs `10` and `11`, until the first
validator set update has been submitted
