import { Callout } from 'nextra-theme-docs'

## Transactions

### Proposal transaction

The on-chain proposal transaction will have the following structure, where `author` address will be address of the account submitting the proposal, and hence the address which receives any deposited funds.

```rust
struct Proposal {
    id: u64,
    content: Vec<u8>,
    author: Address,
    r#type: ProposalType, // This is an enum, in which Wasm code is embedded for DefaultProposal
    votingStartEpoch: Epoch,
    votingEndEpoch: Epoch,
    graceEpoch: Epoch,
}
```

The optional proposal wasm code will be embedded inside the `ProposalType` enum variants to better perform validation through type checking.

### Vote transaction

Vote transactions have the following structure:

```rust
struct OnChainVote {
    id: u64,
    voter: Address,
    yay: ProposalVote,
}
```
where `ProposalVote` is an enum representing a `Yay`, `Nay`, or `Abstain` vote: the yay variant also contains the specific memo (if any) required for that proposal.

Storage writes for a vote transaction are described [here](./storage.mdx#votes).

If non-validating accounts are allowed to vote, delegates will be able to vote only for $\frac{2}{3}$ of the total voting period, while delegators can vote until the end of the voting period. 
If only validators are allowed to vote for the `ProposalType` in question, they are allowed to vote for the entire voting window.

If a delegator votes differently to its delegate, the delegate's vote will be *overridden* 
(e.g. if a delegator has a voting power of 200 and votes opposite to the delegate, then 200 will be subtracted from the voting power of the involved delegate)

### Voting offline

Offline votes are represented as JSON objects with the following structure:

```
{
  proposalHash: Base64<Vec<u8>>,
  voter: Address,
  signature: Base64<Self.proposalHash>,
  vote: Enum(yay|nay|abstain)
}
```

The proposalHash is produced over the concatenation of: `content`, `author`, `votingStart`, `votingEnd`, `voter` and `vote`.
The signature is produced over the hash of the concatenation of: `proposalHash`, `voter` and `vote`.



