## Multi-asset shielded pool

The multi-asset shielded pool (MASP) is an extension to the Sapling circuit which adds support for sending arbitrary assets.

- [Design rationale](./masp/design.mdx)
- [Data types](./masp/data-types.mdx)
- [Storage layout](./masp/storage.mdx)
- [Validity predicate logic](./masp/vp.mdx)
- [Transactions](./masp/txs.mdx)
- [Handlers](./masp/handlers.mdx)

See the following documents:
- [Cryptographic specification](https://github.com/anoma/masp/blob/main/docs/multi-asset-shielded-pool.pdf)
- [Ledger integration](./masp/ledger-integration.mdx)
- [Asset type schema](./masp/asset-type.mdx)
- [Burn and mint](./masp/burn-and-mint.mdx)
- [Convert circuit](./masp/convert-circuit.mdx)
- [Shielded pool incentives](./masp/shielded-pool-incentives.mdx)

## Remarks
Below are miscellaneous remarks on the capabilities and limitations of the current MASP implementation:
* The gas fees for shielded transactions are charged to the signer just like it is done for transparent transactions
  * As a consequence, an amount exceeding the gas fees must be available in a transparent account in order to execute an unshielding transaction - this prevents denial of service attacks
* Using the MASP sentinel transaction key for transaction signing indicates that gas be drawn from the transaction's transparent value pool
  * In this case, the gas will be taken from the MASP transparent address if the shielded transaction is proven to be valid
* With knowledge of its key, a pinned shielded transaction can be directly downloaded or proven non-existent without scanning the entire blockchain
  * It is recommended that pinned transaction's key be derived from the hash of its payment address, something that both transaction parties would share
  * This key must not be reused, this is in order to avoid revealing that multiple transactions are going to the same entity

## Multi-Asset Shielded Pool Specification Differences from Zcash Protocol Specification
The [Multi-Asset Shielded Pool Specification](https://github.com/anoma/masp/blob/main/docs/multi-asset-shielded-pool.pdf) referenced above is in turn an extension to the [Zcash Protocol Specification](https://zips.z.cash/protocol/protocol.pdf). Below, the changes from the Zcash Protocol Specification assumed to have been integrated into the Multi-Asset Shielded Pool Specification are listed:
* [3.2 Notes](https://zips.z.cash/protocol/protocol.pdf#notes)
  * Sapling note tuple must include asset type
  * Note commitment must be parameterized by asset type
  * [3.2.1 Note Plaintexts and Memo Fields](https://zips.z.cash/protocol/protocol.pdf#noteptconcept)
    * Note plaintext tuple must include asset type 
* [4.1.8 Commitment](https://zips.z.cash/protocol/protocol.pdf#abstractcommit)
  * `NoteCommit` and `ValueCommit` must be parameterized by asset type
* [4.7.2 Sending Notes (Sapling)](https://zips.z.cash/protocol/protocol.pdf#saplingsend)
  * Sender must also be able to select asset type
  * `NoteCommit` and hence `cm` must be parameterized by asset type
  * `ValueCommit` and hence `cv` must be parameterized by asset type
  * The note plaintext tuple must include asset type
* [4.8.2 Dummy Notes (Sapling)](https://zips.z.cash/protocol/protocol.pdf#saplingdummynotes)
  * A random asset type must also be selected
  * `NoteCommit` and hence `cm` must be parameterized by asset type
  * `ValueCommit` and hence `cv` must be parameterized by asset type
* [4.13 Balance and Binding Signature (Sapling)](https://zips.z.cash/protocol/protocol.pdf#saplingbalance)
  * The Sapling balance value is now defined as the net value of Spend and [Convert](#convert-descriptions) transfers minus Output transfers.
  * The Sapling balance value is no longer a scalar but a vector of pairs comprising values and asset types
  * Addition, subtraction, and equality checks of Sapling balance values is now done component-wise
  * A Sapling balance value is defined to be non-negative if each of its components is non-negative
  * `ValueCommit` and the value base must be parameterized by asset type
  * Proofs must be updated to reflect the presence of multiple value bases
* [4.19.1 Encryption (Sapling and Orchard)](https://zips.z.cash/protocol/protocol.pdf#saplingandorchardencrypt)
  * The note plaintext tuple must include asset type
* [4.19.2 Decryption using an Incoming Viewing Key (Sapling and Orchard)](https://zips.z.cash/protocol/protocol.pdf#decryptivk)
  * The note plaintext extracted from the decryption must include asset type
* [4.19.3 Decryption using a Full Viewing Key (Sapling and Orchard)](https://zips.z.cash/protocol/protocol.pdf#decryptovk)
  * The note plaintext extracted from the decryption must include asset type
* [5.4.8.2 Windowed Pedersen commitments](https://zips.z.cash/protocol/protocol.pdf#concretewindowedcommit)
  * `NoteCommit` must be parameterized by asset type
* [5.4.8.3 Homomorphic Pedersen commitments (Sapling and Orchard)](https://zips.z.cash/protocol/protocol.pdf#concretehomomorphiccommit)
  * `HomomorphicPedersenCommit`, `ValueCommit`, and value base must be parameterized by asset type
* [5.5 Encodings of Note Plaintexts and Memo Fields](https://zips.z.cash/protocol/protocol.pdf#notept)
  * The note plaintext tuple must include asset type
  * The Sapling note plaintext encoding must use 32 bytes in between `d` and `v` to encode asset type
  * Hence the total size of a note plaintext encoding should be 596 bytes
* [5.6 Encodings of Addresses and Keys](https://zips.z.cash/protocol/protocol.pdf#addressandkeyencoding)
  * Bech32m \[[BIP-0350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\] is used instead of Bech32 \[[ZIP-173](https://zips.z.cash/zip-0173)\] to further encode the raw encodings
* [5.6.3.1 Sapling Payment Addresses](https://zips.z.cash/protocol/protocol.pdf#saplingpaymentaddrencoding)
  * For payment addresses on the Testnet, the Human-Readable Part is "patest"
* [7.1 Transaction Encoding and Consensus](https://zips.z.cash/protocol/protocol.pdf#txnencoding)
  * `valueBalanceSapling` is no longer scalar. Hence it should be replaced by two components:
    * `nValueBalanceSapling`: a `compactSize` indicating number of asset types spanned by balance
    * a length `nValueBalanceSapling` sequence of 40 byte values where:
      * the first 32 bytes encode the asset type
      * the last 8 bytes are an `int64` encoding asset value
  * In between `vSpendsSapling` and `nOutputsSapling` are two additional rows:
    * First row:
      * Bytes: Varies
      * Name: nConvertsMASP
      * Data Type: compactSize
      * Description: The number of Convert descriptions in vConvertsMASP
    * Second row:
      * Bytes: 64*nConvertsMASP
      * Name: vConvertsMASP
      * Data Type: ConvertDescription[nConvertsMASP]
      * Description: A sequence of Convert descriptions, encoded as described in the following section.
* [7.4 Output Description Encoding and Consensus](https://zips.z.cash/protocol/protocol.pdf#outputencodingandconsensus)
  * The `encCiphertext` field must be 612 bytes in order to make 32 bytes room to encode the asset type

### Additional Sections
In addition to the above components of shielded transactions inherited from Zcash, we have the following:
#### Convert Descriptions
Each transaction includes a sequence of zero or more Convert descriptions.

Let `ValueCommit.Output` be as defined in [4.1.8](https://zips.z.cash/protocol/protocol.pdf#abstractcommit) Commitment.
Let `B[Sapling Merkle]` be as defined in [5.3](https://zips.z.cash/protocol/protocol.pdf#constants) Constants.
Let `ZKSpend` be as defined in [4.1.13](https://zips.z.cash/protocol/protocol.pdf#abstractzk) Zero-Knowledge Proving System.

A convert description comprises `(cv, rt, pi)` where
* `cv: ValueCommit.Output` is value commitment to the value of the conversion note
* `rt: B[Sapling Merkle]` is an anchor for the current conversion tree or an archived conversion tree
* `pi: ZKConvert.Proof` is a zk-SNARK proof with primary input `(rt, cv)` for the Convert statement defined at [Burn and Mint conversion transactions in MASP](./burn-and-mint.mdx).
#### Convert Description Encoding
Let `pi_{ZKConvert}` be the zk-SNARK proof of the corresponding Convert statement. `pi_{ZKConvert}` is encoded in the `zkproof` field of the Convert description.

An abstract Convert description, as described above, is encoded in a transaction as an instance of a `ConvertDescription` type:
* First Entry
  * Bytes: 32
  * Name: `cv`
  * Data Type: `byte[32]`
  * Description: A value commitment to the value of the conversion note, `LEBS2OSP_256(repr_J(cv))`.
* Second Entry
  * Bytes: 32
  * Name: `anchor`
  * Data Type: `byte[32]`
  * Description: A root of the current conversion tree or an archived conversion tree, `LEBS2OSP_256(rt^Sapling)`.
* Third Entry
  * Bytes: 192
  * Name: `zkproof`
  * Data Type: `byte[192]`
  * Description: An encoding of the zk-SNARK proof `pi_{ZKConvert}` (see [5.4.10.2](https://zips.z.cash/protocol/protocol.pdf#groth) `Groth16`).
## Required Changes to ZIP 32: Shielded Hierarchical Deterministic Wallets
Below, the changes from [ZIP 32: Shielded Hierarchical Deterministic Wallets](https://zips.z.cash/zip-0032) assumed to have been integrated into the Multi-Asset Shielded Pool Specification are listed:
* [Specification: Key Encodings](https://zips.z.cash/zip-0032#specification-key-encodings)
  * Bech32m \[[BIP-0350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\] is used instead of Bech32 \[[BIP-173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)\] to further encode the raw encodings
* [Sapling extended spending keys](https://zips.z.cash/zip-0032#sapling-extended-spending-keys)
  * For extended spending keys on the Testnet, the Human-Readable Part is "xsktest"
* [Sapling extended full viewing keys](https://zips.z.cash/zip-0032#sapling-extended-full-viewing-keys)
  * For extended full viewing keys on the Testnet, the Human-Readable Part is "xfvktest"