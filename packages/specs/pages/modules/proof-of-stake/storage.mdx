import { Callout } from 'nextra-theme-docs'

## Storage keys

## System parameters

The default values that are relative to epoch duration assume that an epoch last about 24 hours.

- `max_validator_slots`: Maximum consensus validators, default `128`
- `min_validator_stake`: Minimum stake of a validator that allows the validator to enter the `consensus` or `below_capacity` [sets](#validator-sets), in number of native tokens. Because the [inflation system](./inflation-system.mdx#proof-of-stake-rewards) targets a bonding ratio of 2/3, the minimum should be somewhere around `total_supply * 2/3 / max_validator_slots`, but it can and should be much lower to lower the entry cost, as long as it's enough to prevent validation account creation spam that could slow down PoS system update on epoch change
- `pipeline_len`: Pipeline length in number of epochs, default `2`, [see this link](https://github.com/cosmos/cosmos-sdk/blob/019444ae4328beaca32f2f8416ee5edbac2ef30b/docs/architecture/adr-039-epoched-staking.md#pipelining-the-epochs)
- `unboding_len`: Unbonding duration in number of epochs, default `6`
- `cubic_slash_window_width`: The number of epochs above and below the current one in which to collect misbehaviors for use in computing the cubic slash rate, default `1`.
- `votes_per_token`: Used in validators' voting power calculation, default 100â€± (1 voting power unit per 1000 tokens)
- `duplicate_vote_slash_rate`: Portion of validator's stake that should be slashed on a duplicate vote
- `light_client_attack_slash_rate`: Portion of validator's stake that should be slashed on a light client attack

## Storage

The [system parameters](#system-parameters) are written into the storage to allow for their changes. Additionally, each validator may record a new parameters value under their sub-key that they wish to change to, which would override the systems parameters when more than 2/3 voting power are in agreement on all the parameters values.

The validators' data are keyed by the their addresses, conceptually:

```rust,ignore
type Validators = HashMap<Address, Validator>;
```

Epoched data are stored in a structure, conceptually looking like this:

```rust,ignore
struct Epoched<Data> {
  /// The epoch in which this data was last updated
last_update: Epoch,
  /// How many epochs of historical data to keep, this is `0` in most cases
  /// except for validator `total_deltas` and `total_unbonded`, in which 
  /// historical data for up to `pipeline_length + unbonding_length - 1` is 
  /// needed to be able to apply any slashes that may occur.
  /// The value is not actually stored with the data, it's either constant 
  /// value or resolved from PoS parameters on which it may depends.
past_epochs_to_store: u64,
  /// An ordered map in which the head is the data for epoch in which 
  /// the `last_update - past_epochs_to_store` was performed and every
  /// consecutive epoch up to a required length. For system parameters, 
  /// and all the epoched data 
  /// `LENGTH = past_epochs_to_store + pipeline_length + 1`, 
  /// with exception of unbonds, for which 
  /// `LENGTH = past_epochs_to_store + pipeline_length + unbonding_length + 1`.
data: Map<Epoch, Option<Data>>
}
```

Note that not all epochs will have data set, only the ones in which some changes occurred. The only exception to this are the `consensus` and `below_capacity` validator sets, which are written on a new epoch from the latest state into the new epoch by the protocol. This is so that a transaction never has to update the whole validator set when it hasn't changed yet in the current epoch, which would require a copy of the last epoch data and that copy would additionally have to be verified by the PoS validity predicate.

To try to look-up a value for `Epoched` data with discrete values in each epoch (such as the consensus validator set) in the current epoch `n`:

1. read the `data` field at epoch `n`:
2. if there's a value at `n` return it
3. else if `n == last_update - past_epochs_to_store`, return `None`
4. else decrement `n` and repeat this sub-step from 1.

To look-up a value for `Epoched` data with delta values in the current epoch `n`:

1. sum all the values that are not `None` in the `last_update - past_epochs_to_store .. n` epoch range bounded inclusively below and above

To update a value in `Epoched` data with discrete values in epoch `n` with value `new` for epoch `m`:


```python
epochs_to_clear = min(n - last_update, LENGTH)
if epochs_to_clear == 0:
    data[m] = new
else:
    for i in range(last_update - past_epochs_to_store, last_update - past_epochs_to_store + epochs_to_clear):
        data[i] = None
        data[m] = new
        last_update = current_epoch
```

To update a value in `Epoched` data with delta values in epoch `n` with value `delta` for epoch `m`:

```python
epochs_to_sum = min(n - last_update, LENGTH)
if epochs_to_sum == 0:
    data[m] = data[m] + delta if data[m] is not None else delta
else:
    sum_delta = sum(data[i] for i in range(last_update - past_epochs_to_store, last_update - past_epochs_to_store + epochs_to_sum) if data[i] is not None)
    for i in range(last_update - past_epochs_to_store, last_update - past_epochs_to_store + epochs_to_sum):
        data[i] = None
    data[n - past_epochs_to_store] = data[n - past_epochs_to_store] + sum_delta if data[n - past_epochs_to_store] is not None else sum_delta
    data[m] = data[m] + delta if data[m] is not None else delta
last_update = n
```

The invariants for updates in both cases are that `m >= n` (epoched data cannot be updated in an epoch lower than the current epoch) and `m - n <= LENGTH - past_epochs_to_store` (epoched data can only be updated at the future-most epoch set by the `LENGTH - past_epochs_to_store` of the data).

We store the `consensus` validators and validators `below_capacity` in two set, ordered by their voting power. We don't have to store the validators `below_threshold` in a set, because we don't need to know their order.

Note that we still need to store `below_capacity` set in order of their voting power, because when e.g. one of the `consensus` validator's voting power drops below that of a maximum `below_capacity` validator, we need to know which validator to swap in into the `consensus` set. The protocol new epoch update just disregards validators who are not in `consensus` or `below_capacity` sets as `below_threshold` validators and so iteration on unbounded size is avoided. Instead the size of the validator set that is regarded for PoS rewards can be adjusted by the `min_validator_stake` parameter via governance.

Conceptually, this may look like this:

```rust,ignore
type VotingPower = u64;

/// Validator's address with its voting power.
#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct WeightedValidator {
  /// The `voting_power` field must be on top, because lexicographic ordering is
  /// based on the top-to-bottom declaration order and in the `ValidatorSet`
  /// the `WeighedValidator`s these need to be sorted by the `voting_power`.
voting_power: VotingPower,
address: Address,
}

struct ValidatorSet {
  /// Active validator set with maximum size equal to `max_validator_slots`
consensus: BTreeSet<WeightedValidator>,
  /// Other validators that are not in `consensus`, but have stake above `min_validator_stake`
below_threshold: BTreeSet<WeightedValidator>,
}

type ValidatorSets = Epoched<ValidatorSet>;

/// The sum of all validators voting power (including `below_threshold`)
type TotalVotingPower = Epoched<VotingPower>;
```

When any validator's voting power changes, we attempt to perform the following update on the `ValidatorSet`:

```python
# let `validator` be the validator's address, `power_before` and `power_after` be the voting power before and after the change, respectively
validator = "validator's address"
power_before = "voting power before change"
power_after = "voting power after change"

# find if the `power_before` and `power_after` are above the `min_validator_stake` threshold
min_validator_stake = "minimum validator stake"
if power_before < min_validator_stake and power_after < min_validator_stake:
    # if they're both below the threshold, nothing else needs to be done
    pass

# let `power_delta = power_after - power_before`
power_delta = power_after - power_before

# let `min_consensus = consensus.first()` (consensus validator with lowest voting power)
min_consensus = consensus.first()

# let `max_below_capacity = below_capacity.last()` (below_capacity validator with greatest voting power)
max_below_capacity = below_capacity.last()

# find whether the validator was in consensus set, let `was_in_consensus = power_before >= max_below_capacity.voting_power`
was_in_consensus = power_before >= max_below_capacity.voting_power

# find whether the validator was in below capacity set, let `was_below_capacity = power_before > min_validator_stake`
was_below_capacity = power_before > min_validator_stake

if was_in_consensus:
    if power_after >= max_below_capacity.voting_power:
        # update the validator in `consensus` set with `voting_power = power_after`
        pass
    elif power_after < min_validator_stake:
        # remove the validator from `consensus`, insert the `max_below_capacity.address` validator into `consensus` and remove `max_below_capacity.address` from `below_capacity`
        pass
    else:
        # remove the validator from `consensus`, insert it into `below_capacity` and remove `max_below_capacity.address` from `below_capacity` and insert it into `consensus`
        pass
elif was_below_capacity:
    if power_after <= min_consensus.voting_power:
        # update the validator in `below_capacity` set with `voting_power = power_after`
        pass
    elif power_after < min_validator_stake:
        # remove the validator from `below_capacity`
        pass
    else:
        # remove the validator from `below_capacity`, insert it into `consensus` and remove `min_consensus.address` from `consensus` and insert it into `below_capacity`
        pass
else:  # if validator was below minimum stake
    if power_after > min_consensus.voting_power:
        # remove the `min_consensus.address` from `consensus`, insert the `min_consensus.address` into `below_capacity` and insert the validator in `consensus` set with `voting_power = power_after`
        pass
    elif power_after >= min_validator_stake:
        # insert the validator into `below_capacity` set with `voting_power = power_after`
        pass
    else:
        # do nothing
        pass
```

Additionally, for [rewards distribution](./reward-distribution.mdx):

- When a validator moves from `below_threshold` set to either `below_capacity` or `consensus` set, the transaction must also fill in the validator's reward products from its last known value, if any, in all epochs starting from their `last_known_product_epoch` (exclusive) up to the `current_epoch + pipeline_len - 1` (inclusive) in order to make their look-up cost constant (assuming that validator's stake can only be increased at `pipeline_len` offset).
- And on the opposite side, when a stake of a validator from `consensus` or `below_capacity` drops below `min_validator_stake`, we record their `last_known_product_epoch`, so that it can be used if and when the validator's stake goes above `min_validator_stake`.

Within each validator's address space, we store public consensus key, state, total bonded token amount, total unbonded token amount (needed for applying of slashes) and voting power calculated from the total bonded token amount (even though the voting power is stored in the `ValidatorSet`, we also need to have the `voting_power` here because we cannot look it up in the `ValidatorSet` without iterating the whole set):

```rust,ignore
struct Validator {
  consensus_key: Epoched<PublicKey>,
  state: Epoched<ValidatorState>,
  total_deltas: Epoched<token::Amount>,
  total_unbonded: Epoched<token::Amount>,
  voting_power: Epoched<VotingPower>,
}

enum ValidatorState {
  Inactive,
  Candidate,
}
```

The bonds and unbonds are keyed by their identifier:

```rust,ignore
type Bonds = HashMap<BondId, Epoched<Bond>>;
type Unbonds = HashMap<BondId, Epoched<Unbond>>;

struct BondId {
validator: Address,
  /// The delegator address for delegations, or the same as the `validator`
  /// address for self-bonds.
source: Address,
}

struct Bond {
  /// A key is a the epoch set for the bond. This is used in unbonding, where
  // it's needed for slash epoch range check.
deltas: HashMap<Epoch, token::Amount>,
}

struct Unbond {
  /// A key is a pair of the epoch of the bond from which a unbond was created
  /// the epoch of unbonding. This is needed for slash epoch range check.
deltas: HashMap<(Epoch, Epoch), token::Amount>
}
```

For slashes, we store the epoch and block height at which the fault occurred, the slash rate as a fixed-precision decimal type, and the slash type (noted in the [system parameters](#system-parameters)):

```rust,ignore
struct Slash {
epoch: Epoch,
block_height: u64,
rate: Dec,
r#type: SlashType,
}
```
